{
  "version": 3,
  "sources": [
    "@uirouter/angular/directives/uiSrefStatus.ts"
  ],
  "names": [],
  "mappings": "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",
  "file": "uiSrefStatus.js",
  "sourceRoot": "",
  "sourcesContent": [
    "/** @ng2api @module directives */\n/** */\nimport { Directive, Output, EventEmitter, ContentChildren, QueryList } from '@angular/core';\nimport { UISref } from './uiSref';\nimport {\n  PathNode, Transition, TargetState, StateObject, anyTrueR, tail, unnestR, Predicate, UIRouterGlobals, Param, PathUtils, StateOrName\n} from '@uirouter/core';\n\nimport { Subscription } from 'rxjs/Subscription';\nimport { Observable } from 'rxjs/Observable';\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\n\nimport {of} from 'rxjs/observable/of';\nimport {fromPromise} from 'rxjs/observable/fromPromise';\nimport {combineLatest} from 'rxjs/observable/combineLatest';\nimport {switchMap} from 'rxjs/operator/switchMap';\nimport {map} from 'rxjs/operator/map';\nimport {concat} from 'rxjs/operator/concat';\n\n/** @internalapi */\ninterface TransEvt { evt: string; trans: Transition; }\n\n/**\n * UISref status emitted from [[UISrefStatus]]\n */\nexport interface SrefStatus {\n  /** The sref's target state (or one of its children) is currently active */\n  active: boolean;\n  /** The sref's target state is currently active */\n  exact: boolean;\n  /** A transition is entering the sref's target state */\n  entering: boolean;\n  /** A transition is exiting the sref's target state */\n  exiting: boolean;\n  /** The enclosed sref(s) target state(s) */\n  targetStates: TargetState[];\n}\n\n/** @internalapi */\nconst inactiveStatus: SrefStatus = {\n  active: false,\n  exact: false,\n  entering: false,\n  exiting: false,\n  targetStates: [],\n};\n\n/**\n * Returns a Predicate<PathNode[]>\n *\n * The predicate returns true when the target state (and param values)\n * match the (tail of) the path, and the path's param values\n *\n * @internalapi\n */\nconst pathMatches = (target: TargetState): Predicate<PathNode[]> => {\n  if (!target.exists()) return () => false;\n  let state: StateObject = target.$state();\n  let targetParamVals = target.params();\n  let targetPath: PathNode[] = PathUtils.buildPath(target);\n  let paramSchema: Param[] = targetPath.map(node => node.paramSchema)\n      .reduce(unnestR, [])\n      .filter((param: Param) => targetParamVals.hasOwnProperty(param.id));\n\n  return (path: PathNode[]) => {\n    let tailNode = tail(path);\n    if (!tailNode || tailNode.state !== state) return false;\n    let paramValues = PathUtils.paramValues(path);\n    return Param.equals(paramSchema, paramValues, targetParamVals);\n  };\n};\n\n/**\n * Given basePath: [a, b], appendPath: [c, d]),\n * Expands the path to [c], [c, d]\n * Then appends each to [a,b,] and returns: [a, b, c], [a, b, c, d]\n *\n * @internalapi\n */\nfunction spreadToSubPaths(basePath: PathNode[], appendPath: PathNode[]): PathNode[][] {\n  return appendPath.map(node => basePath.concat(PathUtils.subPath(appendPath, n => n.state === node.state)));\n}\n\n/**\n * Given a TransEvt (Transition event: started, success, error)\n * and a UISref Target State, return a SrefStatus object\n * which represents the current status of that Sref:\n * active, activeEq (exact match), entering, exiting\n *\n * @internalapi\n */\nfunction getSrefStatus(event: TransEvt, srefTarget: TargetState): SrefStatus {\n  const pathMatchesTarget = pathMatches(srefTarget);\n  const tc = event.trans.treeChanges();\n\n  let isStartEvent = event.evt === 'start';\n  let isSuccessEvent = event.evt === 'success';\n  let activePath: PathNode[] = isSuccessEvent ? tc.to : tc.from;\n\n  const isActive = () =>\n      spreadToSubPaths([], activePath)\n          .map(pathMatchesTarget)\n          .reduce(anyTrueR, false);\n\n  const isExact = () =>\n      pathMatchesTarget(activePath);\n\n  const isEntering = () =>\n      spreadToSubPaths(tc.retained, tc.entering)\n          .map(pathMatchesTarget)\n          .reduce(anyTrueR, false);\n\n  const isExiting = () =>\n      spreadToSubPaths(tc.retained, tc.exiting)\n          .map(pathMatchesTarget)\n          .reduce(anyTrueR, false);\n\n  return {\n    active: isActive(),\n    exact: isExact(),\n    entering: isStartEvent ? isEntering() : false,\n    exiting: isStartEvent ? isExiting() : false,\n    targetStates: [srefTarget],\n  } as SrefStatus;\n}\n\n/** @internalapi */\nfunction mergeSrefStatus(left: SrefStatus, right: SrefStatus): SrefStatus {\n  return {\n    active: left.active || right.active,\n    exact: left.exact || right.exact,\n    entering: left.entering || right.entering,\n    exiting: left.exiting || right.exiting,\n    targetStates: left.targetStates.concat(right.targetStates),\n  };\n}\n\n/**\n * A directive which emits events when a paired [[UISref]] status changes.\n *\n * This directive is primarily used by the [[UISrefActive]] directives to monitor `UISref`(s).\n *\n * This directive shares two attribute selectors with `UISrefActive`:\n *\n * - `[uiSrefActive]`\n * - `[uiSrefActiveEq]`.\n *\n * Thus, whenever a `UISrefActive` directive is created, a `UISrefStatus` directive is also created.\n *\n * Most apps should simply use `UISrefActive`, but some advanced components may want to process the\n * [[SrefStatus]] events directly.\n *\n * ```js\n * <li (uiSrefStatus)=\"onSrefStatusChanged($event)\">\n *   <a uiSref=\"book\" [uiParams]=\"{ bookId: book.id }\">Book {{ book.name }}</a>\n * </li>\n * ```\n *\n * The `uiSrefStatus` event is emitted whenever an enclosed `uiSref`'s status changes.\n * The event emitted is of type [[SrefStatus]], and has boolean values for `active`, `exact`, `entering`, and `exiting`; also has a [[StateOrName]] `identifier`value.\n *\n * The values from this event can be captured and stored on a component (then applied, e.g., using ngClass).\n *\n * ---\n *\n * A single `uiSrefStatus` can enclose multiple `uiSref`.\n * Each status boolean (`active`, `exact`, `entering`, `exiting`) will be true if *any of the enclosed `uiSref` status is true*.\n * In other words, all enclosed `uiSref` statuses  are merged to a single status using `||` (logical or).\n *\n * ```js\n * <li (uiSrefStatus)=\"onSrefStatus($event)\" uiSref=\"admin\">\n *   Home\n *   <ul>\n *     <li> <a uiSref=\"admin.users\">Users</a> </li>\n *     <li> <a uiSref=\"admin.groups\">Groups</a> </li>\n *   </ul>\n * </li>\n * ```\n *\n * In the above example, `$event.active === true` when either `admin.users` or `admin.groups` is active.\n *\n * ---\n *\n * This API is subject to change.\n */\n\nexport class UISrefStatus {\n  /** current statuses of the state/params the uiSref directive is linking to */\n   uiSrefStatus = new EventEmitter<SrefStatus>(false);\n  /** Monitor all child components for UISref(s) */\n   srefs: QueryList<UISref>;\n\n  /** The current status */\n  status: SrefStatus;\n\n  /** @internalapi */ private _subscription: Subscription;\n  /** @internalapi */ private _srefChangesSub: Subscription;\n  /** @internalapi */ private _srefs$: BehaviorSubject<UISref[]>;\n  /** @internalapi */ private _globals: UIRouterGlobals;\n  constructor(_globals: UIRouterGlobals) {\n    this._globals = _globals;\n    this.status = Object.assign({}, inactiveStatus);\n  }\n\n  ngAfterContentInit() {\n    // Map each transition start event to a stream of:\n    // start -> (success|error)\n    let transEvents$: Observable<TransEvt> = switchMap.call(this._globals.start$, (trans: Transition) => {\n      const event = (evt: string) => ({evt, trans} as TransEvt);\n\n      let transStart$ = of(event(\"start\"));\n      let transResult = trans.promise.then(() => event(\"success\"), () => event(\"error\"));\n      let transFinish$ = fromPromise(transResult);\n\n      return concat.call(transStart$, transFinish$);\n    });\n\n    // Watch the @ContentChildren UISref[] components and get their target states\n\n    // let srefs$: Observable<UISref[]> = of(this.srefs.toArray()).concat(this.srefs.changes);\n    this._srefs$ = new BehaviorSubject(this.srefs.toArray());\n    this._srefChangesSub = this.srefs.changes.subscribe(srefs => this._srefs$.next(srefs));\n\n    let targetStates$: Observable<TargetState[]> =\n        switchMap.call(this._srefs$, (srefs: UISref[]) =>\n            combineLatest<TargetState[]>(srefs.map(sref => sref.targetState$)));\n\n    // Calculate the status of each UISref based on the transition event.\n    // Reduce the statuses (if multiple) by or-ing each flag.\n    this._subscription = switchMap.call(transEvents$, (evt: TransEvt) => {\n      return map.call(targetStates$, (targets: TargetState[]) => {\n        let statuses: SrefStatus[] = targets.map(target => getSrefStatus(evt, target));\n        return statuses.reduce(mergeSrefStatus);\n      });\n    }).subscribe(this._setStatus.bind(this));\n  }\n\n  ngOnDestroy() {\n    if (this._subscription) this._subscription.unsubscribe();\n    if (this._srefChangesSub) this._srefChangesSub.unsubscribe();\n    if (this._srefs$) this._srefs$.unsubscribe();\n    this._subscription = this._srefChangesSub = this._srefs$ = undefined;\n  }\n\n  private _setStatus(status: SrefStatus) {\n    this.status = status;\n    this.uiSrefStatus.emit(status);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{ selector: '[uiSrefStatus],[uiSrefActive],[uiSrefActiveEq]' }, ] },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: UIRouterGlobals, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'uiSrefStatus': [{ type: Output, args: [\"uiSrefStatus\", ] },],\n'srefs': [{ type: ContentChildren, args: [UISref, {descendants: true}, ] },],\n};\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"
  ]
}